{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Preface","text":"<p>In this tutorial, we will build a simple RESTful API application using Symfony and the latest PHP 8.</p>"},{"location":"#audience","title":"Audience","text":"<p>I assume you have some basic knowledge of PHP language, esp. the OOP feature since PHP 5.2. </p> <p>If you are experienced in other OOP program languages, such as Java and C#, it is not difficult to migrate to the latest PHP programming. In fact, a lot of PHP frameworks, such as Zend Framework(now Laminas), Symfony and Doctrine are heavily inspired by Java frameworks, such as Spring and JPA/Hibernate.</p> <p>In this tutorial, we will utilize the latest PHP 8 features to cook the sample application. </p>"},{"location":"#sample-codes","title":"Sample Codes","text":"<p>The source codes of the sample application  are available on Github. Get a copy and explore them yourself.</p> <p>In short, you can clone the project from Github via <code>git clone</code> command.</p> <pre><code>$ git clone https://github.com/hantsy/symfony-rest-sample\n</code></pre>"},{"location":"#contribution","title":"Contribution","text":"<p>Any contributions are welcome. You can file an issue or send a PR on Github directly. </p> <p>If my work is helpful, please help me to spread it out to your circles or buy me a coffee.:)</p>"},{"location":"#about-me","title":"About Me","text":"<p>My name is Hantsy, an independent freelancer from China. I have over 20-year experience in software engineering and worked remotely for about 10 years. </p> <p>If you need some development and technical consulting service, please drop me an email, my email is hantsy@gmail.com.</p> <p>Enjoy reading!</p>"},{"location":"api/","title":"Producing RESTful APIs","text":"<p>Similar to other MVC framework, we can expose RESTful APIs via Symfony <code>Controller</code> component. </p>"},{"location":"api/design/","title":"API Design Consideration","text":"<p>The term <code>REST</code> firstly occurred in the CHAPTER 5: Representational State Transfer (REST) of Roy Fielding's dissertation: Architectural Styles and the Design of Network-based Software. This dissertation had been translated into several languages, including Chinese. But it does not include certain executable guidelines and considerations when designing RESTful APIs, till Richardson Maturity Model (RMM) was born. </p>"},{"location":"api/design/#richardson-maturity-model","title":"Richardson Maturity Model","text":"<p>Richardson Maturity Model defines a series of  Levels used to evaluate the quality of the given RESTful APIs. </p> <ul> <li>Level 0 - only uses HTTP as a transport protocol, but without using any of the  mechanisms of the web. For example,  in the legacy RMI or RPC protocol, it use a single endpoint to handle all requests, the interaction between the client and server is based on your own implementation.</li> <li>Level 1 uses an unique URI endpoint to identify resources, and break a large service endpoint down into multiple smaller resources. For example, in an ecommerce  system, defining various resources, such as /customers, /orders, /products, etc.</li> <li>Level 2 introduces a standard set of verbs so that we handle similar situations in the same way, removing unnecessary variation. For the same resource endpoint, such as /orders, verb <code>POST</code> to place a new order, <code>GET</code> to retrieve all orders.</li> <li>Level 3 introduces discoverability, providing a way of making a protocol more self-documenting. HATEOAS (Hypertext As The Engine Of Application State) is a popular protocol archives self-documenting purpose, for example, in a collection result, using links make it possible to navigate all subresources with extra documentation. </li> </ul> <p>According to these clear rules, when exploring the existing popular APIs in the internet, you will find a lot of public APIs only archive Level 0 or Level 1, in fact they are not REST ready,  although the authors call them REST APIs in their documentation. </p> <p>When building RESTful APIs, make sure the design solution archives RMM Level 2, else we may not call it  REST.  If you can take RMM Level 3 into consideration, it is a great addition.</p>"},{"location":"api/design/#designing-restful-api","title":"Designing RESTful API","text":"<p>If you are new to REST, consider reading Roy's article firstly, and do not miss Martin's explanation of RMM.  To learn these resource in a central place, I suggest the REST API Tutorial  website which explains REST and RMM with detailed examples. </p> <p>Github API is an excellent example of REST API design. When designing your REST API,  consider to use it as a Best Practice reference .</p> <p>Follow the REST convention and the requirements of RMM Level 2, we summarize the RESTful APIs of a blog system into a table list. This list covers all APIs we have designed and implemented in the previous sections.</p> URI Http Method Request Response Description /posts GET 200 [{'id':1, 'title'},{}] Get all posts /posts POST {'title':'test title','content':'test content'} 201 Create a new post /posts/{id} GET 200, {'id':1, 'title'} Get a post by id /posts/{id} PUT {'title':'test title','content':'test content'} 204 Update a post /posts/{id} DELETE 204 Delete a post /posts/{id}/comments GET 200, [{'content':''},{}] Get comments of a post /posts/{id}/comments POST {'content':'test content'} 201 Add comment to a post"},{"location":"api/design/#considering-entity-relations","title":"Considering Entity Relations","text":"<p>When we design RESTful API, besides following the HTTP protocol and REST convention, most of time it is maybe heavily dependent on our past experience and practice.</p> <p>For example,  there is  a scenario: retrieving comments created by the current authenticated user, we could have some different design considerations:</p> <ul> <li>GET /comments?user=hantsy  Use a united endpoint for all cases,  and explicitly add an  query parameter to filter the comments</li> <li>GET /me/comments The endpoint is mounted under the authenticated user endpoint(/me), and implicitly filter comments by the user</li> </ul> <p>Which is better? I prefer the later. </p> <p>Sometimes it is difficult to make a decision this one is good and the other are bad.  Besides identifying the resources, URI path itself is meaningful, it could indicate the root/leaves, whole/parts or parent/children relations. So in my mind, when considering the scenario retrieving comments of a Post,  GET /posts/{id}/comments is better than GET /comments?post=id.</p>"},{"location":"api/ex/","title":"Handling Exception","text":"<p>Symfony kernel provides a event machoism to raise an <code>Exception</code> in <code>Controller</code> class and handle them  in your custom <code>EventListener</code> or <code>EventSubscriber</code> .</p>"},{"location":"api/ex/#creating-postnotfoundexception","title":"Creating PostNotFoundException","text":"<p>For example, create a <code>PostNotFoundException</code>.</p> <pre><code>class PostNotFoundException extends \\RuntimeException\n{\n\n    public function __construct(Uuid $uuid)\n    {\n        parent::__construct(\"Post #\" . $uuid . \" was not found\");\n    }\n\n}\n</code></pre>"},{"location":"api/ex/#creating-eventlistener","title":"Creating EventListener","text":"<p>Create a <code>EventListener</code> to catch this exception, and handle the exception as expected.</p> <pre><code>class ExceptionListener implements LoggerAwareInterface\n{\n    private LoggerInterface $logger;\n\n    public function __construct()\n    {\n    }\n\n    public function onKernelException(ExceptionEvent $event)\n    {\n        // You get the exception object from the received event\n        $exception = $event-&gt;getThrowable();\n        $data = [\"error\" =&gt; $exception-&gt;getMessage()];\n\n        // Customize your response object to display the exception details\n        $response = new JsonResponse($data);\n\n        // HttpExceptionInterface is a special type of exception that\n        // holds status code and header details\n\n        if ($exception instanceof PostNotFoundException) {\n            $response-&gt;setStatusCode(Response::HTTP_NOT_FOUND);\n        } else if ($exception instanceof HttpExceptionInterface) {\n            $response-&gt;setStatusCode($exception-&gt;getStatusCode());\n            $response-&gt;headers-&gt;replace($exception-&gt;getHeaders());\n        } else {\n            $response-&gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);\n        }\n\n        // sends the modified response object to the event\n        $event-&gt;setResponse($response);\n    }\n\n    public function setLogger(LoggerInterface $logger)\n    {\n        $this-&gt;logger = $logger;\n    }\n}\n</code></pre> <p>Next, register this <code>ExceptionListener</code> in config/service.yml file. Then it will be applied in the HTTP request lifecycle.</p> <pre><code>  App\\EventListener\\ExceptionListener:\n    tags:\n      - { name: kernel.event_listener, event: kernel.exception, priority: 50 }\n</code></pre> <p>It binds the <code>event.exception</code>  event to this <code>ExceptionListener</code>, and set <code>priority</code> value to setup the execution order at runtime.</p> <p>Run the following command to show all registered <code>EventListener</code>/<code>EventSubscriber</code>s on event kernel.exception.</p> <pre><code>php bin/console debug:event-subscriber kernel.exception\n</code></pre>"},{"location":"api/ex/#throwing-exception-in-controller","title":"Throwing Exception in Controller","text":"<p>Open the <code>PostController</code>, change the  <code>getById</code> function to the following.</p> <pre><code>#[Route(path: \"/{id}\", name: \"byId\", methods: [\"GET\"])]\nfunction getById(Uuid $id): Response\n{\n    $data = $this-&gt;posts-&gt;findOneBy([\"id\" =&gt; $id]);\n    if ($data) {\n        return $this-&gt;json($data);\n    } else {\n        throw new PostNotFoundException($id);\n    }\n}\n</code></pre> <p>Run the application again, and try to access a single Post through a non-existing id.</p> <pre><code>curl http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 -H \"Accept: application/json\" -v\n&gt; GET /posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 HTTP/1.1\n&gt; Host: localhost:8000\n&gt; User-Agent: curl/7.55.1\n&gt; Accept: application/json\n&gt;\n&lt; HTTP/1.1 404 Not Found\n&lt; Cache-Control: no-cache, private\n&lt; Content-Type: application/json\n&lt; Date: Mon, 22 Nov 2021 03:57:51 GMT\n&lt; X-Powered-By: PHP/8.0.10\n&lt; X-Robots-Tag: noindex\n&lt; Content-Length: 69\n&lt;\n{\"error\":\"Post #1ec3e1e0-17b3-6ed2-a01c-edecc112b438 was not found.\"}\n</code></pre>"},{"location":"api/postctl/","title":"Producing RESTful API","text":"<p>Follow  the REST convention, we are going to create the following APIs.</p> <ul> <li><code>GET  /posts</code>    Get all posts.</li> <li><code>GET /posts/{id}</code> Get a single post by ID, if not found, return status 404 </li> <li><code>POST /posts</code> Create a new post from  request body, add the new post URI to response header <code>Location</code>, and return status 201</li> <li><code>DELETE /posts/{id}</code> Delete a single post by ID, return status 204. If the post was  not found, return status 404 instead.</li> <li>...</li> </ul> <p>Next let's create a <code>Controller</code>  to handle the  incoming requests.</p>"},{"location":"api/postctl/#creating-postcontroller","title":"Creating PostController","text":"<p>To create a <code>Controller</code> skeleton, run the following command and follow the interactive guide to create a controller named <code>PostController</code>.</p> <pre><code># php bin/console make:constroller\n</code></pre> <p>Open src/Controller/PostController.php in IDE.</p> <p>Add a new function to retrieve all posts.  To bind the request path to the controller,  add a  <code>Route</code> attribute on class level and the <code>all</code> function. The former <code>Route</code> will apply to all functions in this controller.</p> <pre><code>#[Route(path: \"/posts\", name: \"posts_\")]\nclass PostController extends AbstractController\n{\n    public function __construct(private PostRepository      $posts)\n    {\n    }\n\n    #[Route(path: \"\", name: \"all\", methods: [\"GET\"])]\n    function all(): Response\n    {\n        $data = $this-&gt;posts-&gt;findAll();\n        return $this-&gt;json($data);\n    }\n\n}\n</code></pre> <p>Start up the application, and try to access the http://localhost:8000/posts, it will throw a circular dependencies exception when rendering the models in JSON view directly. </p> <p>There are some solutions to avoid this, the simplest is break the bi-direction relations before rendering the JSON view.  </p> <p>Add a <code>Ignore</code> attribute on <code>Comment.post</code> and <code>Tag.posts</code>.</p> <pre><code>//src/Entity/Comment.php\nclass Comment\n{\n    #[Ignore]\n    private Post $post;\n}\n\n//src/Entity/Tag.php\nclass Tag\n{\n    #[Ignore]\n    private Collection $posts;\n}\n</code></pre> <p>Alternatively,  the DTO pattern is a good option to transform the data to a plain object that only includes essential fields before rendering in the HTTP response.</p>"},{"location":"api/postctl/#paginating-result","title":"Paginating Result","text":"<p>There are a lot of web applications which provide a input field for typing keyword and paginating the search results. Assume there is a keyword provided by request to match Post title or content fields, a  offset to set the offset position of the pagination, and a limit to set the limited size of the elements per page. Create  a function in the <code>PostRepository</code>, accepts a keyword, offset and limit as arguments.</p> <pre><code>public function findByKeyword(string $q, int $offset = 0, int $limit = 20): Page\n{\n    $query = $this-&gt;createQueryBuilder(\"p\")\n        -&gt;andWhere(\"p.title like :q or p.content like :q\")\n        -&gt;setParameter('q', \"%\" . $q . \"%\")\n        -&gt;orderBy('p.createdAt', 'DESC')\n        -&gt;setMaxResults($limit)\n        -&gt;setFirstResult($offset)\n        -&gt;getQuery();\n\n    $paginator = new Paginator($query, $fetchJoinCollection = false);\n    $c = count($paginator);\n    $content = new ArrayCollection();\n    foreach ($paginator as $post) {\n        $content-&gt;add(PostSummaryDto::of($post-&gt;getId(), $post-&gt;getTitle()));\n    }\n    return Page::of ($content, $c, $offset, $limit);\n}\n</code></pre> <p>Firstly, create a dynamic query using <code>createQueryBuilder</code> ,  then create a Doctrine <code>Paginator</code> instance to execute the query. The <code>Paginator</code> implements <code>Countable</code> interface,  use <code>count</code> to get the count of total elements. Finally, we use a custom <code>Page</code> object to wrap the result.</p> <pre><code>class Page\n{\n    private Collection $content;\n    private int $totalElements;\n    private int $offset;\n    private int $limit;\n\n    #[Pure] public function __construct()\n    {\n        $this-&gt;content = new ArrayCollection();\n    }\n\n\n    public static function of(Collection $content, int $totalElements, int $offset = 0, int $limit = 20): Page\n    {\n        $page = new Page();\n        $page-&gt;setContent($content)\n            -&gt;setTotalElements($totalElements)\n            -&gt;setOffset($offset)\n            -&gt;setLimit($limit);\n\n        return $page;\n    }\n\n    //\n    //getters\n\n}    \n</code></pre>"},{"location":"api/postctl/#handling-query-parameters","title":"Handling Query Parameters","text":"<p>In the <code>PostController</code> , let's improve the the function which serves the route <code>/posts</code>, make it accept query parameters like /posts?q=Symfony&amp;offset=0&amp;limit=10, and ensure the parameters are optional.</p> <pre><code>    #[Route(path: \"\", name: \"all\", methods: [\"GET\"])]\n    function all(Request $req): Response\n    {\n        $keyword = $req-&gt;query-&gt;get('q')??'';\n        $offset = $req-&gt;query-&gt;get('offset')??0;\n        $limit = $req-&gt;query-&gt;get('limit')??10;\n\n        $data = $this-&gt;posts-&gt;findByKeyword($keyword, $offset, $limit);\n        return $this-&gt;json($data);\n    }\n</code></pre> <p>It works but the query parameters handling looks a little ugly.  It is great if they can be handled as the route path parameters.  </p> <p>We can create a custom <code>ArgumentResolver</code> to resolve the bound query arguments.</p> <p>Firstly create an Annotation/Attribute class to identify a query parameter that need to be resolved by this <code>ArgumentResolver</code>.</p> <pre><code>#[Attribute(Attribute::TARGET_PARAMETER)]\nfinal class QueryParam\n{\n    private null|string $name;\n    private bool $required;\n\n    /**\n     * @param string|null $name\n     * @param bool $required\n     */\n    public function __construct(?string $name = null, bool $required = false)\n    {\n        $this-&gt;name = $name;\n        $this-&gt;required = $required;\n    }\n\n    //getters and setters\n\n}    \n</code></pre> <p>Create a custom <code>ArgumentResolver</code> implements the built-in <code>ArgugmentResolverInterface</code>.</p> <pre><code>class QueryParamValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface\n{\n    public function __construct()\n    {\n    }\n\n    private LoggerInterface $logger;\n\n    /**\n     * @inheritDoc\n     */\n    public function resolve(Request $request, ArgumentMetadata $argument)\n    {\n        $argumentName = $argument-&gt;getName();\n        $this-&gt;logger-&gt;info(\"Found [QueryParam] annotation/attribute on argument '\" . $argumentName . \"', applying [QueryParamValueResolver]\");\n        $type = $argument-&gt;getType();\n        $nullable = $argument-&gt;isNullable();\n        $this-&gt;logger-&gt;debug(\"The method argument type: '\" . $type . \"' and nullable: '\" . $nullable . \"'\");\n\n        //read name property from QueryParam\n        $attr = $argument-&gt;getAttributes(QueryParam::class)[0];// `QueryParam` is not repeatable\n        $this-&gt;logger-&gt;debug(\"QueryParam:\" . $attr);\n        //if name property is not set in `QueryParam`, use the argument name instead.\n        $name = $attr-&gt;getName() ?? $argumentName;\n        $required = $attr-&gt;isRequired() ?? false;\n        $this-&gt;logger-&gt;debug(\"Polished QueryParam values: name='\" . $name . \"', required='\" . $required . \"'\");\n\n        //fetch query name from request\n        $value = $request-&gt;query-&gt;get($name);\n        $this-&gt;logger-&gt;debug(\"The request query parameter value: '\" . $value . \"'\");\n\n        //if default value is set and query param value is not set, use default value instead.\n        if (!$value &amp;&amp; $argument-&gt;hasDefaultValue()) {\n            $value = $argument-&gt;getDefaultValue();\n            $this-&gt;logger-&gt;debug(\"After set default value: '\" . $value . \"'\");\n        }\n\n        if ($required &amp;&amp; !$value) {\n            throw new \\InvalidArgumentException(\"Request query parameter '\" . $name . \"' is required, but not set.\");\n        }\n\n        $this-&gt;logger-&gt;debug(\"final resolved value: '\" . $value . \"'\");\n\n        //must return  a `yield` clause\n        yield match ($type) {\n            'int' =&gt; $value ? (int)$value : 0,\n            'float' =&gt; $value ? (float)$value : .0,\n            'bool' =&gt; (bool)$value,\n            'string' =&gt; $value ? (string)$value : ($nullable ? null : ''),\n            null =&gt; null\n        };\n    }\n\n    public function supports(Request $request, ArgumentMetadata $argument): bool\n    {\n        $attrs = $argument-&gt;getAttributes(QueryParam::class);\n        return count($attrs) &gt; 0;\n    }\n\n    public function setLogger(LoggerInterface $logger)\n    {\n        $this-&gt;logger = $logger;\n    }\n}\n</code></pre> <p>At runtime, it calls the <code>supports</code> function to check it the current request satisfy the requirement, if it is ok, then invoke the <code>resovle</code> funtion.</p> <p>In the <code>supports</code> function, we check if the argument is annotated with a <code>QueryParam</code>, if it is existed, then resolved the argument from request query string. </p> <p>Now change the function that serves /posts endpoint to the following.</p> <pre><code>#[Route(path: \"\", name: \"all\", methods: [\"GET\"])]\nfunction all(#[QueryParam] $keyword,\n    #[QueryParam] int $offset = 0,\n    #[QueryParam] int $limit = 20): Response\n    {\n        $data = $this-&gt;posts-&gt;findByKeyword($keyword || '', $offset, $limit);\n        return $this-&gt;json($data);\n    }\n</code></pre> <p>Run the application and test the /posts using <code>curl</code>.</p> <pre><code># curl http://localhost:8000/posts\n{\n    \"content\":[\n        {\n            \"id\":\"1ec3e1e0-17b3-6ed2-a01c-edecc112b436\",\n            \"title\":\"Building Restful APIs with Symfony and PHP 8\"\n        }\n    ],\n    \"totalElements\":1,\n    \"offset\":0,\n    \"limit\":20\n}\n</code></pre>"},{"location":"api/postctl/#retrieving-post","title":"Retrieving Post","text":"<p>Follow the design in the previous section, add another function to <code>PostController</code> to map route <code>/posts/{id}</code> . </p> <pre><code>class PostController extends AbstractController\n{\n    //other functions...\n\n    #[Route(path: \"/{id}\", name: \"byId\", methods: [\"GET\"])]\n    function getById(Uuid $id): Response\n    {\n        $data = $this-&gt;posts-&gt;findOneBy([\"id\" =&gt; $id]);\n        if ($data) {\n            return $this-&gt;json($data);\n        } else {\n            return $this-&gt;json([\"error\" =&gt; \"Post was not found by id:\" . $id], 404);\n        }\n    }\n}\n</code></pre> <p>Run the application, and try to access http://localhost:8000/posts/{id}, it will throw an exception like this.</p> <pre><code>App\\Controller\\PostController::getById(): Argument #1 ($id) must be of type Symfony\\Component\\Uid\\Uuid, string given, cal\nled in D:\\hantsylabs\\symfony5-sample\\rest-sample\\vendor\\symfony\\http-kernel\\HttpKernel.php on line 156\n\n</code></pre> <p>The <code>id</code> in the URI is a string,  can not be  used  as <code>Uuid</code>  directly.</p> <p>Symfony provides <code>ParamConverter</code> to convert the request attributes to the target type. We can create a custom <code>ParamConverter</code> to archive the purpose.</p>"},{"location":"api/postctl/#converting-request-attributes","title":"Converting Request Attributes","text":"<p>Create a  new class <code>UuidParamCovnerter</code> under src/Request/ folder.</p> <pre><code>class UuidParamConverter implements ParamConverterInterface\n{\n    public function __construct(private LoggerInterface $logger)\n    {\n    }\n\n\n    /**\n     * @inheritDoc\n     */\n    public function apply(Request $request, ParamConverter $configuration): bool\n    {\n\n        $param = $configuration-&gt;getName();\n\n        if (!$request-&gt;attributes-&gt;has($param)) {\n            return false;\n        }\n\n        $value = $request-&gt;attributes-&gt;get($param);\n        $this-&gt;logger-&gt;info(\"parameter value:\" . $value);\n        if (!$value &amp;&amp; $configuration-&gt;isOptional()) {\n            $request-&gt;attributes-&gt;set($param, null);\n\n            return true;\n        }\n\n        $data = Uuid::fromString($value);\n        $request-&gt;attributes-&gt;set($param, $data);\n\n        return true;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    public function supports(ParamConverter $configuration): bool\n    {\n        $className = $configuration-&gt;getClass();\n        $this-&gt;logger-&gt;info(\"converting to UUID :{c}\", [\"c\" =&gt; $className]);\n        return $className &amp;&amp; $className == Uuid::class;\n    }\n}\n</code></pre> <p>In the above codes, </p> <ul> <li> <p>The <code>supports</code> function to check the execution environment if matching the requirements</p> </li> <li> <p>The <code>apply</code> function to perform the conversion. if <code>supports</code> returns false, this conversion step will be skipped.</p> </li> </ul>"},{"location":"api/postctl/#creating-post","title":"Creating Post","text":"<p>Follow the REST convention, define the following rule to serve an endpoint to handle the request.</p> <ul> <li>Request matches Http verbs/HTTP Method: <code>POST</code></li> <li>Request matches route endpoint: /posts</li> <li>Set request header  <code>Content-Type</code> value to application/json, and use request body to hold request data as JSON format</li> <li>If successful, return a <code>CREATED</code>(201) Http Status code, and set the response header Location value to the URI of the new created post.</li> </ul> <pre><code>#[Route(path: \"\", name: \"create\", methods: [\"POST\"])]\npublic function create(Request $request): Response\n{\n    $data = $this-&gt;serializer-&gt;deserialize($request-&gt;getContent(), CreatePostDto::class, 'json');\n    $entity = PostFactory::create($data-&gt;getTitle(), $data-&gt;getContent());\n    $this-&gt;posts-&gt;getEntityManager()-&gt;persist($entity);\n\n    return $this-&gt;json([], 201, [\"Location\" =&gt; \"/posts/\" . $entity-&gt;getId()]);\n}\n</code></pre> <p>The <code>posts-&gt;getEntityManager()</code> overrides parent methods to get a <code>EntityManager</code> from parent class, you can also inject <code>ObjectManager</code> or <code>EntityManagerInterface</code> in the  <code>PostController</code> directly to do the persistence work. The Doctrine <code>Repository</code> is mainly designated to build query criteria and execute custom queries.</p>"},{"location":"api/postctl/#converting-request-body","title":"Converting Request Body","text":"<p>We can also use an Annotation/Attribute to erase the raw codes of handling <code>Request</code> object through introducing a custom  <code>ArgumentResolver</code>.</p> <p>Create a <code>Body</code> Attribute.</p> <pre><code>#[Attribute(Attribute::TARGET_PARAMETER)]\nfinal class Body\n{\n}\n</code></pre> <p>Then create a <code>BodyValueResolver</code>.</p> <pre><code>class BodyValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface\n{\n    public function __construct(private SerializerInterface $serializer)\n    {\n    }\n\n    private LoggerInterface $logger;\n\n    /**\n     * @inheritDoc\n     */\n    public function resolve(Request $request, ArgumentMetadata $argument)\n    {\n        $type = $argument-&gt;getType();\n        $this-&gt;logger-&gt;debug(\"The argument type:'\" . $type . \"'\");\n        $format = $request-&gt;getContentType() ?? 'json';\n        $this-&gt;logger-&gt;debug(\"The request format:'\" . $format . \"'\");\n\n        //read request body\n        $content = $request-&gt;getContent();\n        $data = $this-&gt;serializer-&gt;deserialize($content, $type, $format);\n       // $this-&gt;logger-&gt;debug(\"deserialized data:{0}\", [$data]);\n        yield $data;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    public function supports(Request $request, ArgumentMetadata $argument): bool\n    {\n        $attrs = $argument-&gt;getAttributes(Body::class);\n        return count($attrs) &gt; 0;\n    }\n\n    public function setLogger(LoggerInterface $logger)\n    {\n        $this-&gt;logger = $logger;\n    }\n\n</code></pre> <p>In the <code>supports</code> method, it simply detects if the method argument annotated with a <code>Body</code> attribute, then apply <code>resolve</code> method to deserialize the request body  content to a typed object.</p> <p>Run the application and test the endpoint through /posts.</p> <pre><code>curl -v http://localhost:8000/posts -H \"Content-Type:application/json\" -d \"{\\\"title\\\":\\\"test title\\\",\\\"content\\\":\\\"test content\\\"}\"\n&gt; POST /posts HTTP/1.1\n&gt; Host: localhost:8000\n&gt; User-Agent: curl/7.55.1\n&gt; Accept: */*\n&gt; Content-Type:application/json\n&gt; Content-Length: 47\n&gt;\n&lt; HTTP/1.1 201 Created\n&lt; Cache-Control: no-cache, private\n&lt; Content-Type: application/json\n&lt; Date: Sun, 21 Nov 2021 08:42:49 GMT\n&lt; Location: /posts/1ec4aa70-1b21-6bce-93f8-b39330fe328e\n&lt; X-Powered-By: PHP/8.0.10\n&lt; X-Robots-Tag: noindex\n&lt; Content-Length: 2\n&lt;\n[]\n</code></pre>"},{"location":"api/postctl/#validating-request","title":"Validating Request","text":"<p>In the last section,  we convert the request body into an plain object. To validate the object, generally we can inject a <code>Validator</code> service. </p> <pre><code>__constructor(ValidatorInterface $validator, ...){}\n</code></pre> <p>Then invoke <code>validate</code> function to validate the target value, store the validation result into an  <code>errors</code> object,  you can process it later.</p> <pre><code>$errors = $validator-&gt;validate($body);\n\nif (count($errors) &gt; 0) {\n    //...\n}\n</code></pre> <p>Like the above section, you can create  a custom  <code>ArgumentValueResolver</code>  and a specific <code>Attribute</code> to handle the validation automatically. </p> <p>But I hope the official validation attributes can be applied on the controller method arguments directly,  like the existing Bean Validation in a Spring Controller. For example, </p> <pre><code>#[Route(path: \"\", name: \"all\", methods: [\"GET\"])]\nfunction all(string $keyword, #[PositiveOrZero] int $offset = 0, #[Positive] int $limit = 20): Response\n{\n    //...\n}\n\n#[Route(path: \"\", name: \"all\", methods: [\"POST\"])]\nfunction create(#[Body] #[Valid] data: CreatePostCommand): Response\n{\n    //...\n}             \n</code></pre> <p>Please vote issue #43958 if you like include this feature.</p>"},{"location":"api/postctl/#updating-post","title":"Updating Post","text":"<p>Follow the REST convention, define the following rule to serve an endpoint to handle the request.</p> <ul> <li>Request matches Http verbs/HTTP Method: <code>PUT</code></li> <li>Request matches route endpoint: /posts/{id}</li> <li>If successful, return a <code>NO_CONTENT</code>(204) Http Status code and an empty response body.</li> </ul> <pre><code>#[Route(path: \"/{id}\", name: \"update\", methods: [\"PUT\"])]\npublic function update(Uuid $id, #[Body] UpdatePostDto $data): Response\n{\n    $entity = $this-&gt;posts-&gt;findOneBy([\"id\" =&gt; $id]);\n    if (!$entity) {\n        throw new PostNotFoundException($id);\n        //return $this-&gt;json([\"error\" =&gt; \"Post was not found by id:\" . $id], 404);\n    }\n    $entity-&gt;setTitle($data-&gt;getTitle())\n        -&gt;setContent($data-&gt;getContent());\n    $this-&gt;objectManager-&gt;merge($entity);\n    $this-&gt;objectManager-&gt;flush();\n\n    return $this-&gt;json([], 204);\n}\n</code></pre> <p>Firstly we retrieve the existing post through the <code>id</code> path variable.   Update the existing  post with data from the request body, and save it back to the database.</p>"},{"location":"api/postctl/#updating-post-status","title":"Updating Post Status","text":"<p>In the above update operation, we do not update the status field. In a real world application, in some cases we could update a single field instead of the world entity. </p> <p>The status field of a <code>Post</code> can be updated via a standalone endpoint.</p> <p>Follow the REST convention, define the following rule to serve an endpoint to handle the request.</p> <ul> <li>Request matches Http verbs/HTTP Method: <code>PUT</code></li> <li>Request matches route endpoint: /posts/{id}/status</li> <li>If successful, return a <code>NO_CONTENT</code>(204) Http Status code and an empty response body.</li> </ul> <pre><code>#[Route(path: \"/{id}/status\", name: \"update_status\", methods: [\"PUT\"])]\npublic function updateStatus(Uuid $id, #[Body] UpdatePostStatusDto $data): Response\n{\n    $entity = $this-&gt;posts-&gt;findOneBy([\"id\" =&gt; $id]);\n    if (!$entity) {\n        throw new PostNotFoundException($id);\n        //return $this-&gt;json([\"error\" =&gt; \"Post was not found by id:\" . $id], 404);\n    }\n    echo \"update post status::::\" . PHP_EOL;\n    var_export($data);\n    $entity-&gt;setStatus($data-&gt;getStatus());\n    $this-&gt;objectManager-&gt;merge($entity);\n    $this-&gt;objectManager-&gt;flush();\n\n    return $this-&gt;json([], 204);\n}\n</code></pre>"},{"location":"api/postctl/#deleting-post","title":"Deleting Post","text":"<p>Follow the REST convention, define the following rule to serve an endpoint to handle the request.</p> <ul> <li>Request matches Http verbs/HTTP Method: <code>DELETE</code></li> <li>Request matches route endpoint: /posts/{id}</li> <li>If successful, return a <code>NO_CONTENT</code>(204) Http Status code and an empty response body.</li> </ul> <pre><code>#[Route(path: \"/{id}\", name: \"delete\", methods: [\"DELETE\"])]\npublic function deleteById(Uuid $id): Response\n{\n    $entity = $this-&gt;posts-&gt;findOneBy([\"id\" =&gt; $id]);\n    if (!$entity) {\n        throw new PostNotFoundException($id);\n        //return $this-&gt;json([\"error\" =&gt; \"Post was not found by id:\" . $id], 404);\n    }\n    $this-&gt;objectManager-&gt;remove($entity);\n    $this-&gt;objectManager-&gt;flush();\n\n    return $this-&gt;json([], 204);\n}\n</code></pre>"},{"location":"api/sub/","title":"Handling Subresources","text":"<p>In a real world blog application, a <code>Post</code> can be commented, it is a great path that the author can interact with it readers.</p> <p>When designing the APIs such as  adding a comment under a specific post, there are a lot of debates.  For example, POST /comments and POST /posts/{id}/comments which one is more reasonable. Many architects/developers only remember to perform the CRUD operations via HTTP protocol, but do not think through the relations between entities. </p>"},{"location":"api/sub/#adding-comment-to-post","title":"Adding Comment to Post","text":"<p>A comment has to be added under a post, so I would like to design it like this.</p> <ul> <li>Request matches Http verbs/HTTP Method: <code>POST</code></li> <li>Request matches route endpoint: /posts/{id}/comments</li> <li>If successful, return a <code>CREATED</code>(201) Http Status code, and set the response header Location value to the URI of the new created comments.</li> </ul> <p>Add a function to the existing <code>PostController</code>.</p> <pre><code>#[Route(path: \"/{id}/comments\", name: \"addComments\", methods: [\"POST\"])]\n public function addComment(Uuid $id, Request $request): Response\n {\n     $data = $this-&gt;posts-&gt;findOneBy([\"id\" =&gt; $id]);\n     if ($data) {\n         $dto = $this-&gt;serializer-&gt;deserialize($request-&gt;getContent(), CreateCommentDto::class, 'json');\n         $entity = Comment::of($dto-&gt;getContent());\n\n         $this-&gt;objectManager-&gt;persist($entity-&gt;setPost($data));\n         $this-&gt;objectManager-&gt;flush();\n         return $this-&gt;json([], 201, [\"Location\" =&gt; \"/comments/\" . $entity-&gt;getId()]);\n     } else {\n         throw new PostNotFoundException($id);\n         //return $this-&gt;json([\"error\" =&gt; \"Post was not found b}y id:\" . $id], 404);\n     }\n }\n</code></pre>"},{"location":"api/sub/#retrieving-comments","title":"Retrieving Comments","text":"<p>Similar to the above adding comment, when retrieving comments of a specific post, we design the following API.</p> <ul> <li>Request matches Http verbs/HTTP Method: <code>GET</code></li> <li>Request matches route endpoint: /posts/{id}/comments</li> <li>Request header <code>Accept</code> matches <code>application/json</code></li> <li>If successful, return a <code>OK</code>(200) Http Status code, and a collection of data in the response body.</li> </ul> <pre><code>#[Route(path: \"/{id}/comments\", name: \"commentByPostId\", methods: [\"GET\"])]\npublic function getComments(Uuid $id): Response\n{\n    $data = $this-&gt;posts-&gt;findOneBy([\"id\" =&gt; $id]);\n    if ($data) {\n        return $this-&gt;json($data-&gt;getComments());\n    } else {\n        throw new PostNotFoundException($id);\n        //return $this-&gt;json([\"error\" =&gt; \"Post was not found b}y id:\" . $id], 404);\n    }\n}\n</code></pre>"},{"location":"api/sub/#retrieving-single-comment","title":"Retrieving  Single Comment","text":"<p>To retrieve a single comment in some cases, such as for updating purpose, we move the retrieving single comment to the <code>/comments</code> endpoints.</p> <pre><code>//src/Controller/CommentController.php\n#[Route('comments', name: 'comments')]\nclass CommentController extends AbstractController\n{\n\n    public function __construct(private CommentRepository $commentRepository)\n    {\n    }\n\n    #[Route('{id}', name: \"getById\")]\n    public function byId(string $id): Response\n    {\n        $data = $this-&gt;commentRepository-&gt;findOneBy([\"id\" =&gt; $id]);\n        if ($data) {\n            $dto = CommentWithPostSummaryDto::of(\n                $data-&gt;getId(),\n                $data-&gt;getContent(),\n                PostSummaryDto::of($data-&gt;getPost()?-&gt;getId(), $data-&gt;getPost()?-&gt;getTitle())\n            );\n            return $this-&gt;json($dto);\n        } else {\n            return $this-&gt;json([\"error\" =&gt; \"Comment was not found\" . $id], 404);\n        }\n    }\n}\n</code></pre>"},{"location":"data/","title":"Data Accessing with Doctrine","text":"<p>Doctrine ORM is a popular ORM framework in PHP world, which is highly inspired by the existing Java ORM frameworks, esp. JPA specification and Hibernate.</p> <p>There are two core components in Doctrine project:</p> <ul> <li><code>doctrine/dbal</code> is a low-level abstraction layer for database operations, imagine it is the Jdbc role in Java world.</li> <li><code>doctrine/orm</code> is the advanced ORM framework which public APIs are similar to JPA/Hibernate. </li> </ul> <p>Nowadays Doctrine includes a lot of PHP libraries.  In this tutorial we mainly use ORM components.</p>"},{"location":"data/connect/","title":"Connecting to Database","text":"<p>To enable Doctrine support in Symfony project,  install symfony/orm-pack firstly.</p>"},{"location":"data/connect/#installing-doctrine-orm","title":"Installing Doctrine ORM","text":"<p>Open a  terminal, switch to the project root folder and run:</p> <pre><code>$ composer require symfony/orm-pack\n</code></pre> <p>The pack is a virtual Symfony package, it  includes a bundle of  PHP packages and predefined configurations.</p> <p>When it is installed successfully, it will install several packages, updated the package.lock file, add intial Doctrine configurations into the config folder, and update the .env file to add database related configuration, such as connection URL, etc..</p> <p>By the way, install symfony-maker-bundle.</p> <pre><code>$ composer require --dev symfony/maker-bundle\n</code></pre> <p>The maker-bundle provides a series of commands to generate skeleton codes from predefined template, including generating controllers, entities, repository, etc..</p>"},{"location":"data/connect/#configuring-database","title":"Configuring Database","text":"<p>Open the <code>.env</code> file in the project root folder, edit the <code>DATABASE_URL</code> value, setup the database name, username, password.</p> <pre><code>DATABASE_URL=\"postgresql://user:password@127.0.0.1:5432/blogdb?serverVersion=13&amp;charset=utf8\"\n</code></pre> <p>Run the following command to generate a docker compose file template.</p> <pre><code>$ php bin/console make:docker:database\n</code></pre> <p>We change it to the following to start up a Postgres  database instance in development stage.</p> <pre><code>version: \"3.5\" # specify docker-compose version, v3.5 is compatible with docker 17.12.0+\n\n# Define the services/containers to be run\nservices:\n\n  postgres:\n    image: postgres:${POSTGRES_VERSION:-13}-alpine\n    ports:\n      - \"5432:5432\"\n    environment:\n      POSTGRES_DB: ${POSTGRES_DB:-blogdb}\n      # You should definitely change the password in production\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password}\n      POSTGRES_USER: ${POSTGRES_USER:-user}\n    volumes:\n      - ./data/blogdb:/var/lib/postgresql/data:rw\n      - ./pg-initdb.d:/docker-entrypoint-initdb.d\n</code></pre> <p>We will  use <code>UUID</code> as data type of the primary key, add a script to enable <code>uuid-ossp</code> extension in Postgres when it is starting up.</p> <pre><code>-- file: pg-initdb.d/ini.sql\nSET search_path TO public;\nDROP EXTENSION IF EXISTS \"uuid-ossp\";\nCREATE EXTENSION \"uuid-ossp\" SCHEMA public;\n</code></pre> <p>Open config/packages/test/doctrine.yaml, comment out <code>dbname_suffix</code> line.  </p> <p>We use Docker container to bootstrap a database to ensure the application behaviors are same between the development and production.</p>"},{"location":"data/connect/#starting-up-database","title":"Starting up Database","text":"<p>Before starting the application, make sure the database is running.  Run the following command to start up the Postgres in Docker.</p> <pre><code>$ docker compose up postgres\n$ docker ps -a # to list all containers and make the postgres is running\n</code></pre> <p>Now startup the application and make sure there is no exception in the console, that means the database connection is successful.</p> <pre><code>$ symfony server:start\n</code></pre>"},{"location":"data/model/","title":"Data Modeling","text":"<p>We are modeling a simple blog system, it includes the following concepts.</p> <ul> <li>A <code>Post</code> presents an article post in the blog system.</li> <li>A <code>Comment</code> presents the comments under a specific post.</li> <li>The common <code>Tag</code> can be applied on different posts,  which categorizes posts by topic, categories, etc.</li> </ul> <p>You can draft your model relations in your mind or draw it in graph data modeling tools, such as draw.io, etc.  </p> <ul> <li>Post and comments is a <code>one-to-many</code> relation</li> <li>Post and tag is a <code>many-to-many</code> relation</li> </ul> <p>It is easy to convert the idea to real codes via Doctrine <code>Entity</code>.  </p>"},{"location":"data/model/#an-entity-example","title":"An Entity Example","text":"<p>A Doctrine entity is very similar to the JPA <code>Entity</code> class.</p> <pre><code>#[Entity()]\nclass Post\n{\n    #[Id]\n    #[GeneratedValue(strategy: \"AUTO\")\n    #[Column(type: \"integer\")]\n    private ?int $id;\n\n    #[Column(type: \"string\", length: 255)]\n    private string $title;\n\n    #[Column(type: \"string\", length: 255)]\n    private string $content;\n}\n</code></pre> <p>An entity is annotated with <code>Entity</code> attribute, optionally you can setup another <code>Table</code> attribute to configure backed table metadata.</p> <p>An entity should contain an identifier field, annotated wtih a <code>Id</code> attribute. Together with <code>Id</code>, the <code>GeneratedValue</code> is used to identifier generation before inserting into database tables.</p> <p>A <code>Column</code> attribute is used to configure the column metadata in the backed table.</p>"},{"location":"data/model/#identifier-generation-strategy","title":"Identifier Generation Strategy","text":"<p>The <code>GeneratedValue</code> attribute contains an optional parameter  <code>strategy</code> which is used to set the name of identifier generation strategy. Valid values are <code>AUTO</code>, <code>SEQUENCE</code>, <code>IDENTITY</code>, <code>UUID</code>   (deprecated), <code>CUSTOM</code> and <code>NONE</code>.   If not specified, the default value is <code>AUTO</code>.</p> <p>Since Doctrine ORM 2.10.0 and Dbal 3.0,  the deprecated <code>UUID</code> strategy does not work.  We will switch to the <code>CUSTOM</code> strategy and the <code>UuidGenerator</code> form <code>symfony\\uid</code>.</p> <p>Install <code>symfony\\uid</code> firstly.</p> <pre><code>$ composer require symfony/uid\n</code></pre> <p>Use the following instead of the legacy UUID strategy.</p> <pre><code>#[GeneratedValue(strategy: \"CUSTOM\")]\n#[CustomIdGenerator(class: UuidGenerator::class)]\n#[Column(type: \"uuid\", unique: true)]\nprivate ?Uuid $id = null;\n</code></pre> <p>Next, let's create <code>Post</code>, <code>Comment</code> and <code>Tag</code> entities.</p>"},{"location":"data/model/#creating-entities","title":"Creating Entities","text":"<p>Run the following command, and follow the interactive steps to create <code>Post</code>, <code>Comment</code> and <code>Tag</code> one by one.</p> <pre><code>$ php bin/console make:entity\n</code></pre> <p>Finally we got three entities in the src/Entity folder. </p> <p>Change them as you expected.</p> <pre><code>// src/Entity/Post.php\n#[Entity(repositoryClass: PostRepository::class)]\nclass Post\n{\n    #[Id]\n    //#[GeneratedValue(strategy: \"UUID\")\n    //#[Column(type: \"string\", unique: true)]\n    #[Column(type: \"uuid\", unique: true)]\n    #[GeneratedValue(strategy: \"CUSTOM\")]\n    #[CustomIdGenerator(class: UuidGenerator::class)]\n    private ?Uuid $id = null;\n\n    #[Column(type: \"string\", length: 255)]\n    private string $title;\n\n    #[Column(type: \"string\", length: 255)]\n    private string $content;\n\n    #[Column(name: \"created_at\", type: \"datetime\", nullable: true)]\n    private DateTime|null $createdAt = null;\n\n    #[Column(name: \"published_at\", type: \"datetime\", nullable: true)]\n    private DateTime|null $publishedAt = null;\n\n    #[OneToMany(mappedBy: \"post\", targetEntity: Comment::class, cascade: ['persist', 'merge', \"remove\"], fetch: 'LAZY', orphanRemoval: true)]\n    private Collection $comments;\n\n    #[ManyToMany(targetEntity: Tag::class, mappedBy: \"posts\", cascade: ['persist', 'merge'], fetch: 'EAGER')]\n    private Collection $tags;\n\n    public function __construct()\n    {\n        $this-&gt;createdAt = new DateTime();\n        $this-&gt;comments = new ArrayCollection();\n        $this-&gt;tags = new ArrayCollection();\n    }\n    //other getters and setters\n}\n\n// src/Entity/Comment.php\n#[Entity(repositoryClass: CommentRepository::class)]\nclass Comment\n{\n    #[Id]\n    //#[GeneratedValue(strategy: \"UUID\")]\n    #[Column(type: \"uuid\", unique: true)]\n    #[GeneratedValue(strategy: \"CUSTOM\")]\n    #[CustomIdGenerator(class: UuidGenerator::class)]\n    private ?Uuid $id = null;\n\n    #[Column(type: \"string\", length: 255)]\n    private string $content;\n\n    #[Column(name: \"created_at\", type: \"datetime\", nullable: true)]\n    private DateTime|null $createdAt = null;\n\n    #[ManyToOne(targetEntity: \"Post\", inversedBy: \"comments\")]\n    #[JoinColumn(name: \"post_id\", referencedColumnName: \"id\")]\n    private Post $post;\n\n    public function __construct()\n    {\n        $this-&gt;createdAt = new DateTime();\n    }\n    //other getters and setters\n}\n\n//src/Entity/Tag.php\n#[Entity(repositoryClass: TagRepository::class)]\nclass Tag\n{\n    #[Id]\n    //#[GeneratedValue(strategy: \"UUID\")\n    //#[Column(type: \"string\", unique: true)]\n    #[Column(type: \"uuid\", unique: true)]\n    #[GeneratedValue(strategy: \"CUSTOM\")]\n    #[CustomIdGenerator(class: UuidGenerator::class)]\n    private ?Uuid $id = null;\n\n    #[Column(type: \"string\", length: 255)]\n    private ?string $name;\n\n    #[ManyToMany(targetEntity: Post::class, inversedBy: \"tags\")]\n    private Collection $posts;\n\n    public function __construct()\n    {\n        $this-&gt;posts = new ArrayCollection();\n    }\n}\n</code></pre> <p>Note, the <code>one-to-many</code> and <code>many-to-many</code> relations we use a  <code>Collection</code> and initialize a <code>ArrayCollection</code> in the constructor to maintain the relations. The <code>mappedBy</code>, <code>targetEntity</code>, <code>cascade</code>, <code>orphanRemoval</code>, and <code>fetch</code> are easy if you have used Hibernate/JPA before. More details, please read the  OneToMany and ManyToMany section in the Doctrine attribute reference.</p> <p>At the same time, it generated three <code>Repository</code> classes for these entities.</p> <pre><code>// src/Repository/PostRepsoitory.php\nclass PostRepository extends ServiceEntityRepository\n{\n    public function __construct(ManagerRegistry $registry)\n    {\n        parent::__construct($registry, Post::class);\n    }\n}\n\n// src/Repository/CommentRepsoitory.php\nclass CommentRepository extends ServiceEntityRepository\n{\n    public function __construct(ManagerRegistry $registry)\n    {\n        parent::__construct($registry, Comment::class);\n    }\n}\n\n//src/Repository/TagRepository.php\nclass TagRepository extends ServiceEntityRepository\n{\n    public function __construct(ManagerRegistry $registry)\n    {\n        parent::__construct($registry, Tag::class);\n    }\n}\n</code></pre> <p>You can use Doctrine migration to maintain database schema in development and production environments.</p>"},{"location":"data/model/#doctrine-migration","title":"Doctrine Migration","text":"<p>Run the following command to generate a Migration file.</p> <pre><code>$ php bin/console make:migration\n</code></pre> <p>Finally a Migration file is generated in the /migrations folder, the naming is like <code>Version20211104031420</code>.  It is a simple class extended <code>AbstractMigration</code>, there is a <code>up</code> function is used to upgrade to this version and the <code>down</code> function is used to downgrade to the previous version. </p> <p>There are some commands to apply these migrations scripts on database automatically.</p> <pre><code># migrate to the latest\n$ php bin/console doctrine:migrations:migrate\n\n# return to prev version\n$ php bin/console doctrine:migrations:migrate prev\n\n# migrate to next\n$ php bin/console doctrine:migrations:migrate next\n\n# These alias are defined : first, latest, prev, current and next\n\n# certain version fully qualified class name\n$ php bin/console doctrine:migrations:migrate FQCN\n</code></pre> <p>Doctrine bundle also includes some command to maintain database and schema. eg. </p> <pre><code># create and drop database\n$ php bin/console doctrine:database:create\n$ php bin/console doctrine:database:drop\n\n# schema create, drop, update and validate\n$ php bin/console doctrine:schema:create\n$ php bin/console doctrine:schema:drop\n$ php bin/console doctrine:schema:update\n$ php bin/console doctrine:schema:validate\n</code></pre> <p>As you see, these commands are used to execute small tasks, esp,  performing some administration tasks. You can create your own command.</p>"},{"location":"data/operations/","title":"Data Operations","text":"<p>Similar to JPA/Hibernate, Symfony Doctrine bundle provides basic CRUD operations  and flexible criteria builder to create complex queries.</p>"},{"location":"data/operations/#objectmanager-and-objectrepository","title":"<code>ObjectManager</code> and <code>ObjectRepository</code>","text":"<p>In Doctrine common package, there are two core components available for data persistence purpose.</p> <ul> <li><code>ObjectManager</code> is the interface mainly provided for the end user that used  to find, persist, update and delete objects.</li> <li><code>ObjectRepository</code> is used to retrieve instances by more flexible queries. </li> </ul> <p>Doctrine ORM provides derived class of <code>ObjectManager</code> - <code>EntityManagerInerface</code> and its implementation class. It also provides a subclass of <code>ObjectRepository</code> -  <code>EntityRepository</code>.</p> <p>Doctrine also includes a Doctrine ODM package for MongoDB, it uses the same interfaces from the Common package to perform data operations.</p> <p>Symfony integrates Doctrine tightly  and makes these components work in its service container.</p> <ul> <li>There is a <code>EntityManagerInterface</code>  in the service container , you can inject it in any injectable components, such as <code>Controller</code>, <code>Command</code>, etc.</li> <li>Symfony adds an extra <code>EntityServiceRepository</code> which extends from <code>EntityRepository</code>.  All the generated repositories by make bundle are derived from the <code>EntityServiceRepository</code> class. It allows you to access the service container in your own <code>Repository</code>.</li> <li>In your own <code>Repository</code>, you can create complex queries by <code>QueryBuilder</code> API.</li> </ul> <p>The <code>ObjectManager</code> and <code>ObjectRepository</code> provide interoperating methods. </p> <ul> <li>There is a <code>ObjectManager.getRepository</code> method to locate the specific <code>Repository</code> that targets the <code>Entity</code> argument.</li> <li>And there is <code>getEntityManager</code> method available in your own <code>Repository</code>  to retrieve the instance of <code>EntityManagerInterface</code>.</li> </ul>"},{"location":"data/operations/#creating-command","title":"Creating Command","text":"<p>To demonstrate the usage of <code>EntityManagerInterfce</code> ,  we will generate a command firstly, then  inject <code>EntityManagerInterfce</code> via constructor to insert sample data into database. </p> <p>Run the following command to generate a <code>Command</code> from the built-in templates.</p> <pre><code>$ php bin/console make:command add-post\n</code></pre> <p>It will generate a <code>AddPostCommand</code> under src/Command folder. </p> <p>Change it as expected.</p> <pre><code>#[AsCommand(\n    name: 'app:add-post',\n    description: 'Add a short description for your command',\n)]\nclass AddPostCommand extends Command\n{\n\n\n    public function __construct(private EntityManagerInterface $manager)\n    {\n        parent::__construct();\n    }\n\n    protected function configure(): void\n    {\n        $this\n            -&gt;addArgument('title', InputArgument::REQUIRED, 'Title of a post')\n            -&gt;addArgument('content', InputArgument::REQUIRED, 'Content of a post')\n            //-&gt;addOption('option1', null, InputOption::VALUE_NONE, 'Option description')\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $io = new SymfonyStyle($input, $output);\n        $title = $input-&gt;getArgument('title');\n\n        if ($title) {\n            $io-&gt;note(sprintf('Title: %s', $title));\n        }\n\n        $content = $input-&gt;getArgument('content');\n\n        if ($content) {\n            $io-&gt;note(sprintf('Content: %s', $content));\n        }\n\n        $entity = PostFactory::create($title, $content);\n        $this -&gt;manager-&gt;persist($entity);\n        $this -&gt;manager-&gt;flush();\n\n//        if ($input-&gt;getOption('option1')) {\n//            // ...\n//        }\n\n        $io-&gt;success('Post is saved: '.$entity);\n\n        return Command::SUCCESS;\n    }\n}\n</code></pre> <p>The Doctrine  <code>EntityManagerInterface</code> is managed by Symfony Service Container. The <code>persist</code> method is used to persist entities, and <code>flush</code> to commit the transaction.</p> <p>To test if it work as expected, run the following command to execute the newly created <code>add-post</code> command.</p> <pre><code># php bin/console app:add-post \"test title\" \"test content\"\n ! [NOTE] Title: test title                                               \n ! [NOTE] Content: test content                                                             \n [OK] Post is saved: Post: [ id =1ec3d3ec-895d-685a-b712-955865f6c134, title=test title, content=test content, createdAt=1636010040, blishedAt=] \n</code></pre> <p>As you see, it is exectued successfully. It will add a new <code>Post</code> into database. </p>"},{"location":"gs/","title":"Getting Startted","text":"<p>Symfony is a full-featured modularized PHP framework which is used for building all kinds of applications, from traditional web applications to the small Microservice components.</p>"},{"location":"gs/create/","title":"Creating Symfony Project","text":"<p>You can create a  new Symfony project using Symfony CLI or Composer command line tools.</p>"},{"location":"gs/create/#using-symfony-cli","title":"Using Symfony CLI","text":"<p>To create a new Symfony project, you can use <code>symfony new</code> command. </p> <pre><code>$ symfony new rest-sample\n\n// install a webapp pack \n$ symfony new web-sample --webapp\n</code></pre> <p>By default, it will create a simple Symfony skeleton project only with core kernel configuration, which is good to start a lightweight Restful API application.</p> <p>To get full options list of <code>symfony new</code> command, type the following command in your terminal.</p> <pre><code>$ symfony help new\nDescription:\n  Create a new Symfony project\n\nUsage:\n  symfony.exe local:new [options] [--] [&lt;directory&gt;]\n\nArguments:\n  directory  Directory of the project to create\n\n\nOptions:\n  --dir=value      Project directory\n  --version=value  The version of the Symfony skeleton (a version or one of \"lts\", \"stable\", \"next\", or \"previous\")\n  --full           Use github.com/symfony/website-skeleton (deprecated, use --webapp instead)\n  --demo           Use github.com/symfony/demo\n  --webapp         Add the webapp pack to get a fully configured web project\n  --book           Clone the Symfony: The Fast Track book project\n  --docker         Enable Docker support\n  --no-git         Do not initialize Git\n  --cloud          Initialize Platform.sh\n  --debug          Display commands output\n  --php=value      PHP version to use\n</code></pre> <p>Alternatively, you can create it using Composer. </p>"},{"location":"gs/create/#using-composer","title":"Using Composer","text":"<p>Run the following command to create a Symfony  project using <code>composer</code>.</p> <pre><code># composer create-project symfony/skeleton rest-sample\n\n//start a classic website application\n# composer create-project symfony/website-skeleton web-sample\n</code></pre> <p>The later is similar to the <code>symfony new projectname --full</code> to generate a full-featured web project skeleton.</p>"},{"location":"gs/create/#running-application","title":"Running Application","text":"<p>Open your terminal, switch to the project root folder, and run the following command to start the application.</p> <pre><code># symfony server:start\n\n [WARNING] run \"symfony.exe server:ca:install\" first if you want to run the web server with TLS support, or use \"--no-  \n tls\" to avoid this warning                                                                                             \n\nTailing PHP-CGI log file (C:\\Users\\hantsy\\.symfony\\log\\499d60b14521d4842ba7ebfce0861130efe66158\\79ca75f9e90b4126a5955a33ea6a41ec5e854698.log)\nTailing Web Server log file (C:\\Users\\hantsy\\.symfony\\log\\499d60b14521d4842ba7ebfce0861130efe66158.log)\n\n [OK] Web server listening                                                                                              \n      The Web server is using PHP CGI 8.0.10                                                                            \n      http://127.0.0.1:8000                                                                                             \n\n\n[Web Server ] Oct  4 13:33:01 |DEBUG  | PHP    Reloading PHP versions\n[Web Server ] Oct  4 13:33:01 |DEBUG  | PHP    Using PHP version 8.0.10 (from default version in $PATH)\n[Web Server ] Oct  4 13:33:01 |INFO   | PHP    listening path=\"C:\\\\tools\\\\php80\\\\php-cgi.exe\" php=\"8.0.10\" port=61738\n\n</code></pre> <p>Open a browser and navigate to http://127.0.0.1:8000 , it will show the default home page.</p>"},{"location":"gs/hello/","title":"Hello Symfony!","text":"<p>In this post, we will create a simply Somfony project and running the application.</p> <p>Symfony follows the famous MVC pattern to handle request.  The controller  role is responsible for handling incoming request, updating models and  sending results to the HTTP response.</p>"},{"location":"gs/hello/#creating-controller","title":"Creating Controller","text":"<p>Here we will create a simple <code>Controller</code> to experience Symfony request handling.</p> <pre><code>class HelloController\n{\n    /**\n     * @param Request $request\n     * @return Response\n     */\n    #[Route('/hello', name: 'hello', methods:['GET'])]\n    public function sayHello(Request $request): Response\n    {\n        $name = $request-&gt;get(\"name\") ?? \"Symfony\";\n        $data = ['message' =&gt; 'Hello ' . $name];\n\n        return new JsonResponse($data, 200, [], true);\n    }\n}  \n</code></pre> <p>Attribute is a new feature introduced in PHP 8.0, here we use <code>Route</code> attribute to define the routing rule for the <code>HelloController</code>.  </p>"},{"location":"gs/hello/#configuring-routes","title":"Configuring Routes","text":"<p>According to the <code>Route</code> attribute defined in the <code>sayHello</code> method, if the incoming request path is matched with /hello and the request method is <code>GET</code>,  it will be handled by <code>HelloController.sayHello</code> method. The <code>request</code> argument will be filled before invoking this method, it includes all request data in this request context. Every handling method return a <code>Reponse</code>, including the response status, view data, etc.</p> <p>Symfony provides several approaches to configure the routes, such as YAML,  annotations, XML, JSON, etc.  But the PHP official <code>Attribute</code> will be the trend in future. We do not cover other methods in this tutorial. </p> <p>To use the newest PHP 8 <code>Attribute</code> to configure the routing rules, apply the following changes in the project configuration.</p> <ul> <li>Open config/packages/doctrine.yaml,  remove  <code>doctrine/orm/mapping/App/type</code> node in the configuration tree or change its value to <code>attribute</code>.</li> <li>Open composer.json,  make sure  the PHP version set to <code>&gt;=8.0.0</code>.</li> </ul>"},{"location":"gs/hello/#rendering-json-response","title":"Rendering JSON Response","text":"<p>To render the response body into a JSON string,  use a <code>JsonReponse</code> to wrap the response.  The first parameter of <code>JsonReponse</code> accepts an array as data. In PHP, it is a little tedious to convert an object to an array.</p> <p>Symfony provides a simple <code>AbstractController</code> which includes several functions to simplfy the response building and adopt the container and dependency injection management. </p> <p>Change the above controller, make it to extend from <code>AbstractController</code>.  </p> <pre><code>class HelloController extends AbstractController\n{\n    /**\n     * @param Request $request\n     * @return Response\n     */\n    #[Get('/hello', name: 'hello')]\n    public function sayHello(Request $request): Response\n    {\n        $name = $request-&gt;get(\"name\") ?? \"Symfony\";\n        $data = Greeting::of('Hello ' . $name);\n        return $this-&gt;json($data);\n    }\n}\n</code></pre> <p>It simply invoke <code>$this-&gt;json</code> to accept an object and render the response in JSON format, no need to transform the data to an array before rendering response.</p> <p>The <code>Greeting</code> is a plain PHP class.</p> <pre><code>class Greeting\n{\n    private string $message;\n\n    static function of(string $message): Greeting\n    {\n        $data = new Greeting();\n        return $data-&gt;setMessage($message);\n    }\n\n    // use IDE to generate setters and getters\n}    \n</code></pre> <p>Run the application, use <code>curl</code> to test the <code>/hello</code> endpoint.</p> <pre><code>$ curl http://localhost:8000/hello\n{\"message\":\"Hello Symfony\"}\n$ curl http://localhost:8000/hello?name=Hantsy\n{\"message\":\"Hello Hantsy\"}\n</code></pre>"},{"location":"gs/pre/","title":"Prerequisites","text":"<p>Before creating a Symfony application, make sure you have installed the following software:</p> <ul> <li>PHP 8.0+</li> <li>PHP Composer</li> <li>Symfony CLI</li> <li>An text editor or IDE</li> <li>Docker </li> </ul>"},{"location":"gs/pre/#installing-php-and-composer","title":"Installing PHP and Composer","text":"<p>For most Linux users, PHP are available in the official repository, install it directly via the system built-in package management tools.</p> <p>For Windows users, to manage your softwares as Linux users, install Chocolatey firstly.</p> <p>To install PHP 8 and PHP Composer, open a terminal and run the following command.</p> <pre><code>$ choco php composer\n</code></pre> <p>To verify the installation, run the following command.</p> <pre><code>$  php -v\nPHP 8.1.2 (cli) (built: Jan 19 2022 10:13:52) (NTS Visual C++ 2019 x64)\nCopyright (c) The PHP Group\nZend Engine v4.1.2, Copyright (c) Zend Technologies\n\n$ composer -V\nComposer version 2.1.12 2021-11-09 16:02:04\n</code></pre>"},{"location":"gs/pre/#installing-symfony-cli","title":"Installing Symfony CLI","text":"<p>For Linux users, follow the installation guide in the Symfony Download page to install it into your system.</p> <p>For Windows users, Symfony CLI is not available in the Chocolatey repository,  if you are using <code>scoop</code> or <code>gofish</code>, follow the instruction in the Symfony Download page to install it directly. Else download a copy  to your system, add its localtion to the System environment variable <code>PATH</code>.</p> <p>Open a terminal, run the following command to test if it is available in the <code>PATH</code>.</p> <pre><code>$ symfony -V\n\n INFO  A new Symfony CLI version is available (5.3.4, currently running 5.3.3).\n\n       If you installed the Symfony CLI via a package manager, updates are going to be automatic.\n       If not, upgrade by downloading the new version at https://github.com/symfony-cli/symfony-cli/releases\n       And replace the current binary (symfony.exe) by the new one.\n\nSymfony CLI version 5.3.3 (c) 2017-2022 Symfony SAS (2022-02-04T15:07:05Z - stable)\n</code></pre>"},{"location":"gs/pre/#checking-system-requirements","title":"Checking System Requirements","text":"<p>Run the following command to check if your PHP environment satisfices the requirements to run a Symfony application.  </p> <pre><code># symfony check:requirements\n\nSymfony Requirements Checker\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n&gt; PHP is using the following php.ini file:\nC:\\tools\\php80\\php.ini\n\n&gt; Checking Symfony requirements:\n\n....................WWW.........\n\n\n [OK]                                         \n Your system is ready to run Symfony projects \n\n\nOptional recommendations to improve your setup\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n * intl extension should be available\n   &gt; Install and enable the intl extension (used for validators).\n\n * a PHP accelerator should be installed\n   &gt; Install and/or enable a PHP accelerator (highly recommended).\n\n * realpath_cache_size should be at least 5M in php.ini\n   &gt; Setting \"realpath_cache_size\" to e.g. \"5242880\" or \"5M\" in\n   &gt; php.ini* may improve performance on Windows significantly in some\n   &gt; cases.\n\n\nNote  The command console can use a different php.ini file\n~~~~  than the one used by your web server.\n      Please check that both the console and the web server\n      are using the same PHP version and configuration.\n\n</code></pre> <p>Open the php.ini file, adjust the configuration according to the above recommendations info.  </p> <p>If you are not familiar with PHP configuration, backup php.ini firstly before doing modification.</p> <p>And we will use Postgres as database in the sample application, make sure <code>pdo_pgsql</code> and <code>pgsql</code> modules are enabled.</p> <p>Finally,  to show all enabled PHP modules, run:</p> <pre><code>$ php -m\n\n[PHP Modules]\nbcmath\ncalendar\nCore\nctype\ncurl\ndate\ndom\nfilter\nhash\niconv\njson\nlibxml\nmbstring\nmysqlnd\nopenssl\npcre\nPDO\npdo_pgsql\npgsql\nPhar\nreadline\nReflection\nsession\nSimpleXML\nSPL\nstandard\ntokenizer\nxml\nxmlreader\nxmlwriter\nzip\nzlib\n\n[Zend Modules]\n</code></pre>"},{"location":"gs/pre/#php-editor-or-ide","title":"PHP Editor or IDE","text":"<p>Install a text editor or IDE to code PHP,  there are some options:</p> <ul> <li>VSCode + PHP extensions</li> <li>NetBeans IDE includes excellent PHP support</li> <li>IntelliJ IDEA Ultimate Edition or PHPStorm</li> <li>Eclipse with PHP plugins installed</li> </ul> <p>Everything is ready now. In the next section, we will create a Symfony project.</p>"},{"location":"test/","title":"Testing Symfony Application","text":"<p>PHPUnit is the most popular testing framework in PHP world. </p> <p>Symfony has built-in PHPUnit integration and provides two base <code>TestCase</code> classes. </p> <ul> <li><code>KernelTestCase</code> provides a test-scoped Kernel to bootstrap a service container for test purpose.</li> <li><code>WebTestCase</code> runs the application against the test environment configuration. You can create a HttpClient and use it to shake hands with the server side via HTTP protocol.</li> </ul> <p>In the next sections, we will add testing codes to verify if the application work as expected.  </p>"},{"location":"test/testctl/","title":"Testing Controller","text":"<p>As described in the previous sections,  to test Controller/API, create a test class to extend <code>WebTestCase</code>, which provides a plenty of facilities to handle request and assert response.</p>"},{"location":"test/testctl/#creating-postcontrollertest","title":"Creating PostControllerTest","text":"<p>Run the following command to create a test skeleton.</p> <pre><code># php bin/console make:test\n</code></pre> <p>Follow the interactive steps to create a test base on <code>WebTestCase</code>.</p> <pre><code>class PostControllerTest extends WebTestCase\n{\n    public function testGetAllPosts(): void\n    {\n        $client = static::createClient();\n        $crawler = $client-&gt;request('GET', '/posts');\n\n        $this-&gt;assertResponseIsSuccessful();\n\n        //\n        $response = $client-&gt;getResponse();\n        $data = $response-&gt;getContent();\n        //dump($data);\n        $this-&gt;assertStringContainsString(\"Symfony and PHP\", $data);\n    }\n\n}\n</code></pre> <p>If you try to run the test, it will fail. At the moment, there is no any data for testing.</p>"},{"location":"test/testctl/#preparing-data-for-testing-purpose","title":"Preparing Data for Testing Purpose","text":"<p>The <code>doctrine/doctrine-fixtures-bundle</code> is use for populate sample data for testing purpose, and <code>dama/doctrine-test-bundle</code> ensures the data is restored before evey test is running.</p> <p>Install <code>doctrine/doctrine-fixtures-bundle</code> and <code>dama/doctrine-test-bundle</code>.</p> <pre><code>composer require --dev doctrine/doctrine-fixtures-bundle dama/doctrine-test-bundle\n</code></pre> <p>Create a new <code>Fixture</code>. </p> <pre><code># php bin/console make:fixtures\n</code></pre> <p>In the <code>load</code> fucntion, persist some data for tests.</p> <pre><code>class AppFixtures extends Fixture\n{\n    public function load(ObjectManager $manager): void\n    {\n        $data = PostFactory::create(\"Building Restful APIs with Symfony and PHP 8\", \"test content\");\n        $data-&gt;addTag(Tag::of( \"Symfony\"))\n            -&gt;addTag( Tag::of(\"PHP 8\"))\n            -&gt;addComment(Comment::of(\"test comment 1\"))\n            -&gt;addComment(Comment::of(\"test comment 2\"));\n\n        $manager-&gt;persist($data);\n        $manager-&gt;flush();\n    }\n}\n</code></pre> <p>Run the command to load the sample data into database manually.</p> <pre><code># php bin/console doctrine:fixtures:load \n</code></pre> <p>Add the following extension configuration into the <code>phpunit.xml.dist</code>,  thus the data will be purged and recreated for every test running.</p> <pre><code>&lt;extensions&gt;\n    &lt;extension class=\"DAMA\\DoctrineTestBundle\\PHPUnit\\PHPUnitExtension\"/&gt;\n&lt;/extensions&gt;\n</code></pre> <p>Run the following command to execute <code>PostControllerTest.php</code> .</p> <pre><code># php .\\vendor\\bin\\phpunit .\\tests\\Controller\\PostControllerTest.php\n</code></pre> <p>Create a test function to verify in the <code>PostControllerTest</code> file.</p> <pre><code>public function testCreatePost(): void\n{\n    $client = static::createClient();\n    $data = CreatePostDto::of(\"test title\", \"test content\");\n    $crawler = $client-&gt;request(\n        'POST',\n        '/posts',\n        [],\n        [],\n        [],\n        $this-&gt;getContainer()-&gt;get('serializer')-&gt;serialize($data, 'json')\n    );\n\n    $this-&gt;assertResponseIsSuccessful();\n\n    $response = $client-&gt;getResponse();\n    $url = $response-&gt;headers-&gt;get('Location');\n    //dump($data);\n    $this-&gt;assertNotNull($url);\n    $this-&gt;assertStringStartsWith(\"/posts/\", $url);\n}\n</code></pre>"},{"location":"test/testctl/#testing-exception","title":"Testing Exception","text":"<p>We have created a <code>PostNotFoundException</code>  which is thrown when a Post is not found in the  <code>PostController</code>.</p> <p>Add a test to verify if the post is not found and get a 404 status code.</p> <pre><code>public function testGetANoneExistingPost(): void\n{\n    $client = static::createClient();\n    $id = Uuid::v4();\n    $crawler = $client-&gt;request('GET', '/posts/' . $id);\n\n    //\n    $response = $client-&gt;getResponse();\n    $this-&gt;assertResponseStatusCodeSame(404);\n    $data = $response-&gt;getContent();\n    $this-&gt;assertStringContainsString(\"Post #\" . $id . \" was not found\", $data);\n}\n</code></pre> <p>Here we use <code>Uuid:v4</code> to generate a random UUID, of course it should not exist in the backend database. When get a non-existing post, it should return 404 status code and write error message into the response.</p>"},{"location":"test/testdb/","title":"Testing Repository","text":"<p>Symfony provides a test-pack to simplify the configuration for running tests. </p>"},{"location":"test/testdb/#installing-testing-tools","title":"Installing Testing Tools","text":"<p>Run the following command to install PHPUnit and Symfony test-pack. The test-pack will install all essential packages for testing Symfony components and add PHPUnit configuration, such as phpunit.xml.dist.</p> <p>An simple test example written in PHPUnit.</p> <pre><code>class PostTest extends TestCase\n{\n\n    public function testPost()\n    {\n        $p = PostFactory::create(\"tests title\", \"tests content\");\n\n        $this-&gt;assertEquals(\"tests title\", $p-&gt;getTitle());\n        $this-&gt;assertEquals(\"tests content\", $p-&gt;getContent());\n        $this-&gt;assertNotNull( $p-&gt;getCreatedAt());\n    }\n}\n</code></pre> <p>Symfony provides some specific base classes(<code>KernelTestCase</code>, <code>WebTestCase</code>, etc.) to simplfy the testing work in a Symfony project.</p>"},{"location":"test/testdb/#testing-postrepository","title":"Testing  PostRepository","text":"<p>Create a  test class  <code>PostRepositoryTest</code>, make it extends from <code>KernelTestCase</code>. </p> <pre><code>class PostRepositoryTest extends KernelTestCase\n{\n\n    private EntityManagerInterface $entityManager;\n\n    private PostRepository $postRepository;\n\n    protected function setUp(): void\n    {\n        //(1) boot the Symfony kernel\n        $kernel = self::bootKernel();\n        $this-&gt;assertSame('test', $kernel-&gt;getEnvironment());\n        $this-&gt;entityManager = $kernel-&gt;getContainer()\n            -&gt;get('doctrine')\n            -&gt;getManager();\n\n        //(2) use static::getContainer() to access the service container\n        $container = static::getContainer();\n\n        //(3) get PostRepository from container.\n        $this-&gt;postRepository = $container-&gt;get(PostRepository::class);\n    }\n\n    protected function tearDown(): void\n    {\n        parent::tearDown();\n        $this-&gt;entityManager-&gt;close();\n    }\n\n    public function testCreatePost(): void\n    {\n        $entity = PostFactory::create(\"test post\", \"test content\");\n        $this-&gt;entityManager-&gt;persist($entity);\n        $this-&gt;entityManager-&gt;flush();\n        $this-&gt;assertNotNull($entity-&gt;getId());\n\n        $byId = $this-&gt;postRepository-&gt;findOneBy([\"id\" =&gt; $entity-&gt;getId()]);\n        $this-&gt;assertEquals(\"test post\", $byId-&gt;getTitle());\n        $this-&gt;assertEquals(\"test content\", $byId-&gt;getContent());\n    }\n\n}\n</code></pre> <p>The <code>KernelTestCase</code> contains all facilities to bootstrap the application kernel and provides service container in tests.</p> <p>In the above codes, there is a <code>setUp</code> function which is used to prepare the testing environment before running the tests.</p> <p>In this function, it boots up the application kernel. After it is booted, a test scoped Service Container is available, you can fetch the managed service in the container.</p> <p>Here we retrieve <code>EntityManagerInterface</code> and <code>PostRepository</code> from service container.</p> <p>In the <code>testCreatePost</code> function, it persists a <code>Post</code> entity firstly, then find this post by id and verify the title and content fields.</p> <p>Currently, PHPUnit does not include PHP 8 Attribute support, the testing codes looks like the legacy JUnit 4 code style.</p>"},{"location":"tips/","title":"Tips and Tricks","text":"<p>In the chapter, we will include some small tips and tricks to improve the development productivity.</p>"},{"location":"tips/enum/","title":"Using Enum","text":""},{"location":"tips/enum/#using-enum-in-symfony","title":"Using Enum in Symfony","text":"<p>PHP 8.1 introduces the official Enum support.   Doctrine brought Enum type support in its ORM framework,  and Symfony added serialization and deserialization support of a Enum type.  </p> <p>It is time to migrate your projects to use PHP Enum if you are using 3rd-party enumeration solutions.</p> <p>To use PHP Enum, you have to upgrade to PHP 8.1, and set the PHP version to <code>8.1</code>  in the project composer file.</p> <pre><code>{\n    //...\n    \"require\": {\n        \"php\": \"&gt;=8.1\",\n        //...\n    }\n}\n</code></pre>"},{"location":"tips/enum/#creating-enum-class","title":"Creating Enum Class","text":"<p>For example, we will add a <code>Status</code> to the <code>Post</code> entity, and defined several fixed values of the post status.</p> <pre><code>&lt;?php\n\nnamespace App\\Entity;\n\nenum Status: string\n{\n    case Draft = \"DRAFT\";\n    case PendingModerated = \"PENDING_MODERATED\";\n    case Published = \"PUBLISHED\";\n}\n</code></pre> <p>Here we use a string backed enum, add a field in the <code>Post</code> class.</p> <pre><code>#[Column(type: \"string\", enumType: Status::class)]\nprivate Status $status;\n</code></pre> <p>Note, set the enumType as the <code>Status</code> class.  It will store the status value as a string in the database tables.</p> <p>In the <code>Post</code> constructor, assign a default value to the status.</p> <pre><code>public function __construct()\n{\n    $this-&gt;status = Status::Draft;\n    //...\n}\n</code></pre> <p>Now everything is ok. </p>"},{"location":"tips/enum/#creating-httpmethod","title":"Creating HttpMethod","text":"<p>When we setup the <code>Route</code> attribute on the Controller class,  we use a literal value to set up the HTTP method.</p> <pre><code>#[Route(path: \"/{id}\", name: \"byId\", methods: [\"GET\"])]\n</code></pre> <p>For the methods value, there are only several options available to choose. Obviously, if introducing Enum, it will provide a type-safe way to  setup the values and decrease the typo errors.</p> <p>Create an Enum named <code>HttpMethod</code>.</p> <pre><code>&lt;?php\n\nnamespace App\\Annotation;\n\nenum HttpMethod\n{\n    case GET;\n    case POST;\n    case HEAD;\n    case OPTIONS;\n    case PATCH;\n    case PUT;\n    case DELETE;\n}\n</code></pre> <p>Then refactor the <code>Route</code> attribute and create a series of attributes(<code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Delete</code>, etc.) that are mapped to different HTTP methods.</p> <pre><code>//file : src/Annotation/Get.php\n#[Attribute]\nclass Get extends Route\n{\n    public function getMethods()\n    {\n        return [HttpMethod::GET-&gt;name];\n    }\n\n}\n\n//file : src/Annotation/Head.php\n#[Attribute]\nclass Head extends Route\n{\n    public function getMethods()\n    {\n        return [HttpMethod::HEAD-&gt;name];\n    }\n\n}\n\n//file : src/Annotation/Options.php\n#[Attribute]\nclass Options extends Route\n{\n    public function getMethods()\n    {\n        return [HttpMethod::OPTIONS-&gt;name];\n    }\n\n}\n\n//file : src/Annotation/Patch.php\n#[Attribute]\nclass Patch extends Route\n{\n    public function getMethods()\n    {\n        return [HttpMethod::PATCH-&gt;name];\n    }\n}\n\n//file : src/Annotation/Post.php\n#[Attribute]\nclass Post extends Route\n{\n    public function getMethods()\n    {\n        return [HttpMethod::POST-&gt;name];\n    }\n}\n\n//file : src/Annotation/Put.php\n#[Attribute]\nclass Put extends Route\n{\n    public function getMethods()\n    {\n        return [HttpMethod::PUT-&gt;name];\n    }\n}\n\n//file : src/Annotation/Delete.php\n#[Attribute]\nclass Delete extends Route\n{\n    public function getMethods()\n    {\n        return [HttpMethod::DELETE-&gt;name];\n    }\n}\n</code></pre> <p>Now you can polish the <code>PostController</code>, use these attributes instead. As you see, the naming of the new attributes literally look more clear.</p> <pre><code>#[Route(path: \"/posts\", name: \"posts_\")]\nclass PostController extends AbstractController\n{\n\n    // constructor...\n\n    // #[Route(path: \"\", name: \"all\", methods: [\"GET\"])]\n    #[Get(path: \"\", name: \"all\")]\n    public function all(#[QueryParam] string $keyword,\n                        #[QueryParam] int $offset = 0,\n                        #[QueryParam] int $limit = 20): Response\n    {\n        //...\n    }\n\n    // #[Route(path: \"/{id}\", name: \"byId\", methods: [\"GET\"])]\n    #[Get(path: \"/{id}\", name: \"byId\")]\n    public function getById(Uuid $id): Response\n    {\n       //...\n    }\n\n    //#[Route(path: \"\", name: \"create\", methods: [\"POST\"])]\n    #[Post(path: \"\", name: \"create\")]\n    public function create(#[Body] CreatePostDto $data): Response\n    {\n        //...\n    }\n\n    //#[Route(path: \"/{id}\", name: \"update\", methods: [\"PUT\"])]\n    #[Put(path: \"/{id}\", name: \"update\")]\n    public function update(Uuid $id, #[Body] UpdatePostDto $data): Response\n    {\n        //...\n    }\n\n    // #[Route(path: \"/{id}/status\", name: \"update_status\", methods: [\"PUT\"])]\n    #[Put(path: \"/{id}/status\", name: \"update_status\")]\n    public function updateStatus(Uuid $id, #[Body] UpdatePostStatusDto $data): Response\n    {\n       //...\n    }\n\n    //#[Route(path: \"/{id}\", name: \"delete\", methods: [\"DELETE\"])]\n    #[Delete(path: \"/{id}\", name: \"delete\")]\n    public function deleteById(Uuid $id): Response\n    {\n        //...\n    }\n\n    // comments sub resources.\n    //#[Route(path: \"/{id}/comments\", name: \"commentByPostId\", methods: [\"GET\"])]\n    #[GET(path: \"/{id}/comments\", name: \"commentByPostId\")]\n    public function getComments(Uuid $id): Response\n    {\n      //...\n    }\n\n    //#[Route(path: \"/{id}/comments\", name: \"addComments\", methods: [\"POST\"])]\n    #[Post(path: \"/{id}/comments\", name: \"addComments\")]\n    public function addComment(Uuid $id, Request $request): Response\n    {\n        //...\n    }\n\n}\n\n</code></pre> <p>Run the application again to make sure it works.</p>"},{"location":"tips/v7/","title":"Upgrade to Symfony v7","text":"<p>Symfony has just released Symfony 7.0, there are a lot of breaking changes introduced in this version.</p> <p>In this post, we will use Symfony Rest Example project as an example, and show how I upgrade to v7 step by step. </p>"},{"location":"tips/v7/#backup-existing-codes","title":"Backup Existing Codes","text":"<p>Firstly, let's create a GIT tag on the existing codes, and back up the project. </p> <pre><code>git tag v6.x \ngit push origin v6.x\n</code></pre> <p>For those still use Symfony 6.x, please check the tag <code>v6.x</code> or download a copy from the project tag page. </p> <p>Create a new branch to prepare the upgrading work.</p> <pre><code>git checkout -b v7\n</code></pre>"},{"location":"tips/v7/#upgrade-symfony-packages-to-v7","title":"Upgrade Symfony Packages to v7","text":"<p>Import the project source codes into an IDE(PHPStorm or NetBeans IDE) or VSCode( with PHP support).</p> <p>Open <code>composer.json</code> file, change all symfony packages version to <code>7.0.*</code>.</p> <pre><code>{\n  \"name\": \"hantsy/symfony-rest-sample\",\n  \"description\": \"Restful APIs examples built with Symfony 7 and PHP 8\",\n  \"authors\": [\n    {\n      \"name\": \"Hantsy Bai\",\n      \"email\": \"hantsy@gmail.com\"\n    }\n  ],\n  \"type\": \"project\",\n  \"license\": \"GPL-3.0-or-later\",\n  \"minimum-stability\": \"stable\",\n  \"prefer-stable\": true,\n  \"require\": {\n    \"php\": \"&gt;=8.2\",\n    \"ext-ctype\": \"*\",\n    \"ext-iconv\": \"*\",\n    \"composer/package-versions-deprecated\": \"^1.11.99.4\",\n    \"doctrine/annotations\": \"^2.0\",\n    \"doctrine/doctrine-bundle\": \"^2.4\",\n    \"doctrine/doctrine-migrations-bundle\": \"^3.1\",\n    \"doctrine/orm\": \"^2.9\",\n    \"phpdocumentor/reflection-docblock\": \"^5.2\",\n    \"symfony/asset\": \"7.0.*\",\n    \"symfony/console\": \"7.0.*\",\n    \"symfony/dotenv\": \"7.0.*\",\n    \"symfony/expression-language\": \"7.0.*\",\n    \"symfony/flex\": \"^2.0.1\",\n    \"symfony/framework-bundle\": \"7.0.*\",\n    \"symfony/monolog-bundle\": \"^3.7\",\n    \"symfony/property-access\": \"7.0.*\",\n    \"symfony/property-info\": \"7.0.*\",\n    \"symfony/runtime\": \"7.0.*\",\n    \"symfony/serializer\": \"7.0.*\",\n    \"symfony/uid\": \"7.0.*\",\n    \"symfony/validator\": \"7.0.*\",\n    \"symfony/yaml\": \"7.0.*\"\n  },\n  \"config\": {\n    \"optimize-autoloader\": true,\n    \"preferred-install\": {\n      \"*\": \"dist\"\n    },\n    \"allow-plugins\": true,\n    \"sort-packages\": true\n  },\n  \"autoload\": {\n    \"psr-4\": {\n      \"App\\\\\": \"src/\"\n    }\n  },\n  \"autoload-dev\": {\n    \"psr-4\": {\n      \"App\\\\Tests\\\\\": \"tests/\"\n    }\n  },\n  \"replace\": {\n    \"symfony/polyfill-ctype\": \"*\",\n    \"symfony/polyfill-iconv\": \"*\",\n    \"symfony/polyfill-php72\": \"*\"\n  },\n  \"scripts\": {\n    \"auto-scripts\": {\n      \"cache:clear\": \"symfony-cmd\",\n      \"assets:install %PUBLIC_DIR%\": \"symfony-cmd\"\n    },\n    \"post-install-cmd\": [\n      \"@auto-scripts\"\n    ],\n    \"post-update-cmd\": [\n      \"@auto-scripts\"\n    ],\n    \"test\": \"php bin/phpunit\"\n  },\n  \"conflict\": {\n    \"symfony/symfony\": \"*\"\n  },\n  \"extra\": {\n    \"symfony\": {\n      \"allow-contrib\": false,\n      \"require\": \"7.0.*\"\n    }\n  },\n  \"require-dev\": {\n    \"dama/doctrine-test-bundle\": \"^8.0\",\n    \"doctrine/doctrine-fixtures-bundle\": \"^3.4\",\n    \"phpunit/phpunit\": \"^9.5\",\n    \"symfony/browser-kit\": \"7.0.*\",\n    \"symfony/css-selector\": \"7.0.*\",\n    \"symfony/maker-bundle\": \"^1.34\",\n    \"symfony/phpunit-bridge\": \"7.0.*\"\n  }\n}\n</code></pre> <p>We remove <code>sensio/framework-extra-bundle</code> and <code>nelmio/cors-bundle</code> from the package list due to the compatibility with the new v7. </p> <ul> <li>The former is deprecated in v7 and not recommended in new projects. We will use new API to replace them.</li> <li>The later does not release a Symfony v7 compatible version at the moment.</li> </ul> <p>Remove <code>composer.lock</code>, try to run <code>composer install</code> command in a terminal to install new packages and rerun the built-in recipes for this project.</p>"},{"location":"tips/v7/#refresh-codes-with-new-apis","title":"Refresh Codes with New APIs","text":"<p>There are a few classes that need to align with the new APIs in Symfony v7. </p> <p>Firstly, we used <code>ArgumentResolver</code> in <code>sensio/framework-extra-bundle</code> to convert parameters to <code>Uuid</code>. In Symfony v7, the <code>ValueResolver</code> is the replacement. More details please check Extending Action Argument Resolving. </p> <p>And there is a built-in UidValueResolver can be used to convert the parameter to <code>Uuidv4</code>, so we can give up our custom Uuid converter, and switch to use the official one. </p> <p>Simply remove the existing <code>src/ParamConverter/UuidParamConverter</code>. </p> <p>Next, let's update the <code>BodyValueResolver</code> and <code>QueryParamValueResolver</code>. The original <code>ArgumentValueResolverInterface</code> is removed in v7, the replacement is <code>ValueResolverInterface</code>, which is similar to the old <code>ArgumentValueResolverInterface</code>, but there is no <code>supports</code> method to override.</p> <p>We adjust the existing codes slightly to make it work seamlessly.</p> <pre><code>class QueryParamValueResolver implements ValueResolverInterface, LoggerAwareInterface\n{\n    public function __construct()\n    {\n    }\n\n    private LoggerInterface $logger;\n\n    /**\n     * @inheritDoc\n     */\n    public function resolve(Request $request, ArgumentMetadata $argument): iterable\n    {\n        if (!$this-&gt;supports($request, $argument)) return [];\n        ...\n    }    \n</code></pre> <p>We reuse <code>supports</code> method to determine if skip the execution of argument resolving. Similarly, we adjust the <code>BodyValueResolver</code> as expected.</p> <p>Rerun <code>composer install</code>, we get an error like the following.</p> <pre><code>!!  Symfony\\Component\\ErrorHandler\\Error\\FatalError {#307\n!!    #message: \"Compile Error: Declaration of App\\Annotation\\Delete::getMethods() must be compatible with Symfony\\Component\\Routing\\Attribute\\Route::getMethods(): array\"\n!!    #code: 0\n!!    #file: \"D:\\hantsylabs\\symfony5-sample\\src\\Annotation\\Delete.php\"\n!!    #line: 11\n!!    -error: array:4 [\n!!      \"type\" =&gt; 64\n!!      \"message\" =&gt; \"Declaration of App\\Annotation\\Delete::getMethods() must be compatible with Symfony\\Component\\Routing\\Attribute\\Route::getMethods(): array\"\n!!      \"file\" =&gt; \"D:\\hantsylabs\\symfony5-sample\\src\\Annotation\\Delete.php\"\n!!      \"line\" =&gt; 11\n!!    ]\n!!  }\n!!  PHP Fatal error:  Declaration of App\\Annotation\\Delete::getMethods() must be compatible with Symfony\\Component\\Routing\\Attribute\\Route::getMethods(): array in D:\\hantsylabs\\symfony5-sample\\src\\Annotation\\Delete.php on line 11\n</code></pre> <p>In Symfony v7, all methods and properties in classes require type declaration. For developers, it is good to write type safe codes.</p> <p>Symfony provides a simple script to upgrade existing codes and apply type declaration automatically.</p> <pre><code>vendor/bin/patch-type-declarations\n</code></pre> <p>More information about the type declaration, check Symfony 7.0 Type Declarations.</p> <p>Rerun <code>composer install</code>, we get an new error like the following.</p> <pre><code>!!  In Loader.php line 63:\n!!                                                                                 \n!!    Cannot load resource \"../../src/Controller/\". Make sure there is a loader   \n!!    supporting the \"annotation\" type.   \n</code></pre> <p>We should use the new attributes config to replace the legacy annotations config for loading controllers. </p> <ol> <li>Remove <code>config/routes/annotations.yaml</code>.</li> <li> <p>Create a new file <code>config/routes/attributes.yaml</code>, fill in the following content.</p> <p>```yaml controllers:     resource:         path: ../../src/Controller/         namespace: App\\Controller     type: attribute</p> <p>kernel:     resource: App\\Kernel     type: attribute ```</p> </li> </ol> <p>More information about Route, check Creating Routes as Attributes.</p> <p>Now the <code>composer install</code> command should be executed successfully.</p> <p>When running the tests, there are several deprecated warning info.</p> <p>The <code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Delete</code>, etc. that we created as examples of demonstrating attributes now raise warning info like the <code>Route</code> could be final in future. Thus means in a further version, these custom attributes will not work.</p> <ol> <li>Remove the entire <code>src\\Annotations</code> folder.</li> <li>Open the <code>PostController</code>, use original <code>Route</code> attribute instead.</li> </ol> <p>Note, if you use <code>Route</code> from <code>Symfony\\Component\\Routing\\Annotation\\Route</code>, change it to use the new <code>Symfony\\Component\\Routing\\Attribute\\Route</code> instead.</p> <p>The left another two warning info are from Doctrine configuration.</p> <p>Open <code>config/packages/doctrine.yaml</code>, add the following two lines.</p> <pre><code>doctrine:\n    dbal:\n        url: '%env(resolve:DATABASE_URL)%'\n        use_savepoints: true  // add this line\n        ...\n    orm:\n        auto_generate_proxy_classes: true\n        enable_lazy_ghost_objects: true // add this line\n        ...\n</code></pre> <p>I have not researched the new changes in Doctrine, these configuration is provided in the warning info.</p> <p>Now run the tests, all tests should be passed.</p>"},{"location":"tips/v7/#upgrade-to-phpunit-10","title":"Upgrade to PHPUnit 10","text":"<p>Run the following command to update PHPUnit to 10.x.</p> <pre><code>composer recipes:update symfony/phpunit-bridge\n</code></pre> <p>Then update the PHPUnit packages to <code>^10.0</code>.</p> <pre><code>composer install\n</code></pre> <p>When running the tests, there are some deprecation information in the test result.</p> <p>Run the following command to migrate the configuration to PHPUnit 10 compatible format.</p> <pre><code>vendor/bin/phpunit --migrate-configuration\n</code></pre> <p>You will find the Symfony test listener is removed by this script, because <code>listener</code> is not a valid element in PHPUnit 10 configuration. Let's wait for a new replacement in a further version.</p> <p>Manually add a <code>source</code> element into the phpunit.xml.dist. </p> <pre><code>  &lt;source&gt;\n    &lt;include&gt;\n        &lt;directory suffix=\".php\"&gt;src&lt;/directory&gt;\n    &lt;/include&gt;\n  &lt;/source&gt;\n</code></pre> <p>Now run the tests again, all tests should be passed.</p>"},{"location":"tips/v7/#update-php-versions-on-github-actions","title":"Update PHP versions on Github Actions","text":"<p>Finally, we should update the PHP version in Github actions workflow file, drop PHP 8.1 from the versoin list, and add PHP 8.3 as build environment. PHP 8.1 is no longer supported in the new Symfony v7.</p> <p>The working codes is available via my Github, check out the symfony-rest-sample and explore it yourself.</p>"},{"location":"tips/v8/","title":"Upgrade to Symfony v8","text":"<p>Check the notes in this Gist: https://gist.github.com/hantsy/b8fd3bdca1cadfa980112846abc8cbfd#file-notes-symfony-v8-md</p>"}]}